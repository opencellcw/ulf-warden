/**
 * Repository Security Template Generator
 *
 * Generates security best-practice files for new repositories.
 * Auto-applied by bot-factory and available as standalone tool.
 *
 * Includes:
 * - .gitignore (language-aware)
 * - Pre-commit hook (secret detection)
 * - Security config (GCP Secret Manager integration)
 * - Credential loading boilerplate
 */

import { log } from '../logger';

export type RepoLanguage = 'python' | 'typescript' | 'node' | 'go' | 'generic';

export interface SecurityTemplateOptions {
  language: RepoLanguage;
  projectName: string;
  gcpProject?: string;
  includeGcpSecretManager?: boolean;
  includePreCommitHook?: boolean;
  includeSecurityConfig?: boolean;
}

export interface GeneratedFile {
  path: string;
  content: string;
  executable?: boolean;
}

// ─── Secret Detection Patterns (used by pre-commit hook) ───

const SECRET_PATTERNS = [
  'AKIA[0-9A-Z]{16}',                    // AWS Access Key
  'AIza[A-Za-z0-9_-]{35}',               // Google API Key
  'sk-[A-Za-z0-9]{20,}',                 // OpenAI / Anthropic API Key
  'ghp_[A-Za-z0-9]{36}',                 // GitHub PAT
  'ghs_[A-Za-z0-9]{36}',                 // GitHub App Token
  'glpat-[A-Za-z0-9_-]{20}',             // GitLab PAT
  'xox[bpas]-[A-Za-z0-9-]+',             // Slack Token
  'sk_live_[A-Za-z0-9]{24,}',            // Stripe Live Key
  'rk_live_[A-Za-z0-9]{24,}',            // Stripe Restricted Key
  'SG\\.[A-Za-z0-9_-]{22}\\.[A-Za-z0-9_-]{43}', // SendGrid
  'ya29\\.[A-Za-z0-9_-]+',               // Google OAuth
  'eyJ[A-Za-z0-9_-]{10,}\\.[A-Za-z0-9_-]{10,}', // JWT
  '-----BEGIN (RSA |EC )?PRIVATE KEY-----', // Private keys
  '-----BEGIN CERTIFICATE-----',           // Certificates
  'mongodb\\+srv://[^\\s]+',              // MongoDB connection string
  'postgres://[^\\s]+',                    // PostgreSQL connection string
  'mysql://[^\\s]+',                       // MySQL connection string
  'redis://[^\\s]+:[^\\s]+@',             // Redis with auth
];

// ─── .gitignore Templates ───

const GITIGNORE_BASE = `# ══════════════════════════════════════════════
# Security - NEVER commit these
# ══════════════════════════════════════════════
.env
.env.*
.env.local
.env.production
!.env.example
*.pem
*.key
*.p12
*.pfx
*-key.json
credentials.json
secrets.yaml
secrets.yml
secrets.json
service-account*.json
gcp-key*.json
*.credential*

# Config files that may contain secrets
config.yaml
config.yml
config.json
!config.example.yaml
!config.example.yml
!config.example.json

# OS
.DS_Store
Thumbs.db
desktop.ini

# IDE
.vscode/settings.json
.idea/
*.swp
*.swo
*~

# Logs
*.log
logs/

# Data
*.db
*.sqlite3
data/
`;

const GITIGNORE_PYTHON = `
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
dist/
*.egg-info/
*.egg
venv/
env/
.venv/
.pytest_cache/
.mypy_cache/
.coverage
htmlcov/
`;

const GITIGNORE_TYPESCRIPT = `
# Node / TypeScript
node_modules/
dist/
build/
.next/
*.js.map
*.tsbuildinfo
coverage/
.nyc_output/
`;

const GITIGNORE_GO = `
# Go
vendor/
*.exe
*.test
*.out
go.sum
`;

// ─── Pre-commit Hook ───

function generatePreCommitHook(): string {
  const patternsRegex = SECRET_PATTERNS
    .map(p => `  '${p}'`)
    .join('\n');

  return `#!/bin/bash
# Pre-commit hook: Detect secrets before they get committed
# Auto-generated by Ulf Security Template

RED='\\033[0;31m'
YELLOW='\\033[1;33m'
GREEN='\\033[0;32m'
NC='\\033[0m'

echo -e "\${GREEN}[security]\\033[0m Running secret detection..."

# Patterns that indicate secrets
PATTERNS=(
${patternsRegex}
)

FOUND_SECRETS=0
FILES_CHECKED=0

# Get staged files (only text files)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR | grep -v -E '\\.(png|jpg|jpeg|gif|ico|svg|woff|ttf|eot|mp3|mp4|zip|gz|tar|pdf)$')

for FILE in $STAGED_FILES; do
  if [ ! -f "$FILE" ]; then
    continue
  fi

  FILES_CHECKED=$((FILES_CHECKED + 1))

  for PATTERN in "\${PATTERNS[@]}"; do
    MATCHES=$(grep -nE "$PATTERN" "$FILE" 2>/dev/null || true)
    if [ -n "$MATCHES" ]; then
      echo ""
      echo -e "\${RED}[BLOCKED] Potential secret found in $FILE:\${NC}"
      echo "$MATCHES" | head -3
      FOUND_SECRETS=$((FOUND_SECRETS + 1))
    fi
  done
done

# Also check for common secret filenames
DANGEROUS_FILES=('.env' '.env.local' '.env.production' 'credentials.json' 'secrets.yaml' 'secrets.yml' 'service-account.json')
for DFILE in "\${DANGEROUS_FILES[@]}"; do
  if git diff --cached --name-only | grep -qx "$DFILE"; then
    echo ""
    echo -e "\${RED}[BLOCKED] Attempting to commit sensitive file: $DFILE\${NC}"
    FOUND_SECRETS=$((FOUND_SECRETS + 1))
  fi
done

if [ $FOUND_SECRETS -gt 0 ]; then
  echo ""
  echo -e "\${RED}========================================\${NC}"
  echo -e "\${RED}  COMMIT BLOCKED: $FOUND_SECRETS secret(s) detected\${NC}"
  echo -e "\${RED}========================================\${NC}"
  echo ""
  echo "  Options:"
  echo "  1. Remove the secrets and use environment variables"
  echo "  2. Add files to .gitignore"
  echo "  3. Use: git commit --no-verify (NOT recommended)"
  echo ""
  exit 1
fi

echo -e "\${GREEN}[security] $FILES_CHECKED files checked, no secrets found.\${NC}"
exit 0
`;
}

// ─── GCP Secret Manager Integration (Python) ───

function generatePythonSecretManager(gcpProject: string): string {
  return `"""
Google Secret Manager Integration
Auto-generated security module - load secrets from GCP Secret Manager
"""
import os
import logging
from typing import Optional

logger = logging.getLogger(__name__)

# Try to import Google Cloud Secret Manager
try:
    from google.cloud import secretmanager
    GCP_AVAILABLE = True
except ImportError:
    GCP_AVAILABLE = False
    logger.info("google-cloud-secret-manager not installed, using env vars only")


class SecretManager:
    """
    Loads secrets with fallback chain:
    1. Environment variables (highest priority - for local dev)
    2. Google Secret Manager (production)
    3. Default value (if provided)
    """

    def __init__(self, project_id: str = "${gcpProject}"):
        self.project_id = project_id or os.environ.get("GCP_PROJECT_ID", "")
        self._client = None
        self._cache: dict[str, str] = {}

        if GCP_AVAILABLE and self.project_id:
            try:
                self._client = secretmanager.SecretManagerServiceClient()
                logger.info(f"Secret Manager initialized (project: {self.project_id})")
            except Exception as e:
                logger.warning(f"Secret Manager init failed: {e}")

    def get(self, key: str, default: Optional[str] = None) -> Optional[str]:
        """Get a secret value. Checks env vars first, then GCP Secret Manager."""
        # 1. Environment variable (always takes priority)
        env_val = os.environ.get(key)
        if env_val:
            return env_val

        # 2. Cache
        if key in self._cache:
            return self._cache[key]

        # 3. GCP Secret Manager
        if self._client and self.project_id:
            try:
                name = f"projects/{self.project_id}/secrets/{key}/versions/latest"
                response = self._client.access_secret_version(request={"name": name})
                value = response.payload.data.decode("utf-8")
                self._cache[key] = value
                logger.info(f"Loaded secret from GCP: {key}")
                return value
            except Exception as e:
                logger.debug(f"Secret {key} not found in GCP: {e}")

        return default

    def require(self, key: str) -> str:
        """Get a secret, raise if not found."""
        value = self.get(key)
        if value is None:
            raise RuntimeError(
                f"Required secret '{key}' not found. "
                f"Set it as env var or in GCP Secret Manager."
            )
        return value


# Singleton
secrets = SecretManager()
`;
}

// ─── GCP Secret Manager Integration (TypeScript) ───

function generateTypeScriptSecretManager(gcpProject: string): string {
  return `/**
 * Google Secret Manager Integration
 * Auto-generated security module - load secrets from GCP Secret Manager
 */

import { log } from '../logger';

let SecretManagerServiceClient: any;
try {
  SecretManagerServiceClient = require('@google-cloud/secret-manager').SecretManagerServiceClient;
} catch {
  // Not installed - will use env vars only
}

class SecretLoader {
  private projectId: string;
  private client: any;
  private cache = new Map<string, string>();

  constructor(projectId = '${gcpProject}') {
    this.projectId = projectId || process.env.GCP_PROJECT_ID || '';

    if (SecretManagerServiceClient && this.projectId) {
      try {
        this.client = new SecretManagerServiceClient();
        log.info('[SecretLoader] GCP Secret Manager initialized');
      } catch (err: any) {
        log.warn('[SecretLoader] GCP Secret Manager not available', { error: err.message });
      }
    }
  }

  /**
   * Get a secret. Checks env vars first, then GCP Secret Manager.
   */
  async get(key: string, defaultValue?: string): Promise<string | undefined> {
    // 1. Environment variable
    if (process.env[key]) return process.env[key];

    // 2. Cache
    if (this.cache.has(key)) return this.cache.get(key);

    // 3. GCP Secret Manager
    if (this.client && this.projectId) {
      try {
        const name = \`projects/\${this.projectId}/secrets/\${key}/versions/latest\`;
        const [version] = await this.client.accessSecretVersion({ name });
        const value = version.payload.data.toString('utf8');
        this.cache.set(key, value);
        return value;
      } catch {
        // Not found in GCP
      }
    }

    return defaultValue;
  }

  /**
   * Get a secret, throw if not found.
   */
  async require(key: string): Promise<string> {
    const value = await this.get(key);
    if (!value) {
      throw new Error(
        \`Required secret '\${key}' not found. Set it as env var or in GCP Secret Manager.\`
      );
    }
    return value;
  }
}

export const secretLoader = new SecretLoader();
`;
}

// ─── Security Config ───

function generateSecurityConfig(projectName: string, gcpProject: string): string {
  return `# Security Configuration for ${projectName}
# Auto-generated by Ulf Security Template

# Secret Management
secrets:
  provider: gcp_secret_manager  # or "env" for local dev
  gcp_project: "${gcpProject}"
  # Secrets to load on startup (key = env var name, value = GCP secret name)
  required:
    - ANTHROPIC_API_KEY
  optional:
    - DISCORD_BOT_TOKEN
    - SLACK_BOT_TOKEN

# IAM Best Practices
iam:
  # Service account should have ONLY these roles
  recommended_roles:
    - roles/secretmanager.secretAccessor  # Read secrets
    - roles/logging.logWriter             # Write logs
    - roles/monitoring.metricWriter       # Write metrics
  # NEVER grant these
  dangerous_roles:
    - roles/owner
    - roles/editor
    - roles/iam.securityAdmin
    - roles/secretmanager.admin

# Runtime Security
runtime:
  # Validate these secrets exist on startup
  validate_on_startup: true
  # Max age for cached secrets (seconds)
  cache_ttl: 3600
  # Log secret access (without values)
  audit_access: true

# Git Security
git:
  # Pre-commit hook enabled
  pre_commit_hook: true
  # Block commits containing these patterns
  blocked_patterns:
    - "AKIA[0-9A-Z]{16}"      # AWS keys
    - "AIza[A-Za-z0-9_-]{35}" # Google API keys
    - "sk-[A-Za-z0-9]{20,}"   # OpenAI/Anthropic keys
    - "ghp_[A-Za-z0-9]{36}"   # GitHub PATs
    - "-----BEGIN.*PRIVATE KEY-----"

# Monitoring
monitoring:
  # Alert on these events
  alerts:
    - billing_anomaly
    - secret_access_failure
    - unauthorized_api_call
  # Essential contacts for security alerts
  essential_contacts:
    - type: security
      # Configure via: gcloud essential-contacts create
`;
}

// ─── .env.example Generator ───

function generateEnvExample(language: RepoLanguage): string {
  return `# ══════════════════════════════════════════════
# Environment Variables
# Copy to .env and fill in real values
# NEVER commit .env - only .env.example
# ══════════════════════════════════════════════

# Google Cloud
GCP_PROJECT_ID=your-project-id
GCP_REGION=us-central1

# API Keys (use GCP Secret Manager in production)
ANTHROPIC_API_KEY=sk-ant-...
# DISCORD_BOT_TOKEN=
# SLACK_BOT_TOKEN=

# Runtime
NODE_ENV=development
LOG_LEVEL=info
`;
}

// ─── Main Generator ───

/**
 * Generate all security template files for a new repository
 */
export function generateSecurityTemplate(options: SecurityTemplateOptions): GeneratedFile[] {
  const {
    language,
    projectName,
    gcpProject = 'your-gcp-project',
    includeGcpSecretManager = true,
    includePreCommitHook = true,
    includeSecurityConfig = true,
  } = options;

  const files: GeneratedFile[] = [];

  // 1. .gitignore
  let gitignore = GITIGNORE_BASE;
  switch (language) {
    case 'python':
      gitignore += GITIGNORE_PYTHON;
      break;
    case 'typescript':
    case 'node':
      gitignore += GITIGNORE_TYPESCRIPT;
      break;
    case 'go':
      gitignore += GITIGNORE_GO;
      break;
  }
  files.push({ path: '.gitignore', content: gitignore.trim() + '\n' });

  // 2. .env.example
  files.push({ path: '.env.example', content: generateEnvExample(language) });

  // 3. Pre-commit hook
  if (includePreCommitHook) {
    files.push({
      path: '.githooks/pre-commit',
      content: generatePreCommitHook(),
      executable: true,
    });
  }

  // 4. GCP Secret Manager integration
  if (includeGcpSecretManager) {
    if (language === 'python') {
      files.push({
        path: 'src/security/secret_manager.py',
        content: generatePythonSecretManager(gcpProject),
      });
    } else if (language === 'typescript' || language === 'node') {
      files.push({
        path: 'src/security/secret-loader.ts',
        content: generateTypeScriptSecretManager(gcpProject),
      });
    }
  }

  // 5. Security config
  if (includeSecurityConfig) {
    files.push({
      path: 'config/security.yaml',
      content: generateSecurityConfig(projectName, gcpProject),
    });
  }

  log.info('[SecurityTemplate] Generated files', {
    projectName,
    language,
    fileCount: files.length,
    files: files.map(f => f.path),
  });

  return files;
}

/**
 * Get the list of secret patterns for external use (e.g., scanning)
 */
export function getSecretPatterns(): string[] {
  return [...SECRET_PATTERNS];
}

/**
 * Quick check if a string contains potential secrets
 */
export function containsSecrets(text: string): { found: boolean; matches: string[] } {
  const matches: string[] = [];
  for (const pattern of SECRET_PATTERNS) {
    const regex = new RegExp(pattern);
    if (regex.test(text)) {
      matches.push(pattern);
    }
  }
  return { found: matches.length > 0, matches };
}
