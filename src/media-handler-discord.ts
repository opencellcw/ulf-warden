import { Message } from 'discord.js';
import axios from 'axios';
import fs from 'fs';
import path from 'path';
import { log } from './logger';
import { MediaMetadata } from './media-handler';

/**
 * Upload media to Discord
 */
export async function uploadMediaToDiscord(
  message: Message,
  media: MediaMetadata,
  text?: string
): Promise<void> {
  try {
    log.info('[MediaHandler] Uploading media to Discord', {
      type: media.type,
      hasUrl: !!media.url,
      hasFilePath: !!media.filePath,
      channel: message.channel.id
    });

    const DISCORD_FILE_LIMIT = 25 * 1024 * 1024; // 25MB (free tier)

    // For URLs: Try embed first (for images/videos), fallback to download
    if (media.url) {
      // For images and videos from trusted sources, use embeds
      if (media.type === 'image' || media.type === 'video') {
        try {
          await message.reply({
            content: text || `âœ¨ Generated ${media.type}`,
            embeds: [{
              ...(media.type === 'image' && { image: { url: media.url } }),
              ...(media.type === 'video' && { video: { url: media.url } }),
              color: 0x5865F2, // Discord blurple
              footer: { text: 'Generated by Ulfberht' }
            }]
          });

          log.info('[MediaHandler] Media sent as Discord embed');
          return;
        } catch (embedError) {
          log.warn('[MediaHandler] Failed to send as embed, downloading instead', {
            error: embedError instanceof Error ? embedError.message : String(embedError)
          });
        }
      }

      // Download and upload as file
      log.info('[MediaHandler] Downloading from URL', { url: media.url.substring(0, 100) });

      const response = await axios.get(media.url, {
        responseType: 'arraybuffer',
        timeout: 60000,
        maxContentLength: DISCORD_FILE_LIMIT,
        headers: {
          'User-Agent': 'Ulfberht-Warden/1.0'
        }
      });

      const fileBuffer = Buffer.from(response.data);

      // Check size limit
      if (fileBuffer.length > DISCORD_FILE_LIMIT) {
        await message.reply(
          `âš ï¸ File too large for Discord (${(fileBuffer.length / 1024 / 1024).toFixed(2)}MB > 25MB limit)\n\n` +
          `Download directly: ${media.url}`
        );
        return;
      }

      // Generate filename
      const urlParts = media.url.split('/');
      const urlFilename = urlParts[urlParts.length - 1].split('?')[0];
      const filename = urlFilename && urlFilename.includes('.')
        ? urlFilename
        : `${media.type}_${Date.now()}.${getExtension(media.type)}`;

      await message.reply({
        content: text || `âœ¨ Generated ${media.type}`,
        files: [{
          attachment: fileBuffer,
          name: filename
        }]
      });

      log.info('[MediaHandler] Media uploaded to Discord', {
        filename,
        size: `${(fileBuffer.length / 1024).toFixed(2)}KB`
      });
    }
    // For local files (ElevenLabs audio)
    else if (media.filePath) {
      log.info('[MediaHandler] Reading local file', { path: media.filePath });

      const fileBuffer = fs.readFileSync(media.filePath);

      // Check size limit
      if (fileBuffer.length > DISCORD_FILE_LIMIT) {
        await message.reply(
          `âš ï¸ Audio file too large for Discord (${(fileBuffer.length / 1024 / 1024).toFixed(2)}MB > 25MB limit)`
        );
        return;
      }

      const filename = path.basename(media.filePath);

      await message.reply({
        content: text || 'ðŸŽµ Generated audio',
        files: [{
          attachment: media.filePath,
          name: filename
        }]
      });

      log.info('[MediaHandler] Audio uploaded to Discord', {
        filename,
        size: `${(fileBuffer.length / 1024).toFixed(2)}KB`
      });
    } else {
      throw new Error('No file path or URL provided');
    }
  } catch (error: any) {
    log.error('[MediaHandler] Failed to upload media to Discord', {
      error: error.message,
      stack: error.stack,
      type: media.type
    });
    throw error;
  }
}

/**
 * Get file extension for media type
 */
function getExtension(type: string): string {
  switch (type) {
    case 'image': return 'png';
    case 'video': return 'mp4';
    case 'audio': return 'mp3';
    default: return 'bin';
  }
}
