"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadMediaToDiscord = uploadMediaToDiscord;
const axios_1 = __importDefault(require("axios"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const logger_1 = require("./logger");
/**
 * Upload media to Discord
 */
async function uploadMediaToDiscord(message, media, text) {
    try {
        logger_1.log.info('[MediaHandler] Uploading media to Discord', {
            type: media.type,
            hasUrl: !!media.url,
            hasFilePath: !!media.filePath,
            channel: message.channel.id
        });
        const DISCORD_FILE_LIMIT = 25 * 1024 * 1024; // 25MB (free tier)
        // For URLs: Try embed first (for images/videos), fallback to download
        if (media.url) {
            // For images and videos from trusted sources, use embeds
            if (media.type === 'image' || media.type === 'video') {
                try {
                    await message.reply({
                        content: text || `âœ¨ Generated ${media.type}`,
                        embeds: [{
                                ...(media.type === 'image' && { image: { url: media.url } }),
                                ...(media.type === 'video' && { video: { url: media.url } }),
                                color: 0x5865F2, // Discord blurple
                                footer: { text: 'Generated by Ulfberht' }
                            }]
                    });
                    logger_1.log.info('[MediaHandler] Media sent as Discord embed');
                    return;
                }
                catch (embedError) {
                    logger_1.log.warn('[MediaHandler] Failed to send as embed, downloading instead', {
                        error: embedError instanceof Error ? embedError.message : String(embedError)
                    });
                }
            }
            // Download and upload as file
            logger_1.log.info('[MediaHandler] Downloading from URL', { url: media.url.substring(0, 100) });
            const response = await axios_1.default.get(media.url, {
                responseType: 'arraybuffer',
                timeout: 60000,
                maxContentLength: DISCORD_FILE_LIMIT,
                headers: {
                    'User-Agent': 'Ulfberht-Warden/1.0'
                }
            });
            const fileBuffer = Buffer.from(response.data);
            // Check size limit
            if (fileBuffer.length > DISCORD_FILE_LIMIT) {
                await message.reply(`âš ï¸ File too large for Discord (${(fileBuffer.length / 1024 / 1024).toFixed(2)}MB > 25MB limit)\n\n` +
                    `Download directly: ${media.url}`);
                return;
            }
            // Generate filename
            const urlParts = media.url.split('/');
            const urlFilename = urlParts[urlParts.length - 1].split('?')[0];
            const filename = urlFilename && urlFilename.includes('.')
                ? urlFilename
                : `${media.type}_${Date.now()}.${getExtension(media.type)}`;
            await message.reply({
                content: text || `âœ¨ Generated ${media.type}`,
                files: [{
                        attachment: fileBuffer,
                        name: filename
                    }]
            });
            logger_1.log.info('[MediaHandler] Media uploaded to Discord', {
                filename,
                size: `${(fileBuffer.length / 1024).toFixed(2)}KB`
            });
        }
        // For local files (ElevenLabs audio)
        else if (media.filePath) {
            logger_1.log.info('[MediaHandler] Reading local file', { path: media.filePath });
            const fileBuffer = fs_1.default.readFileSync(media.filePath);
            // Check size limit
            if (fileBuffer.length > DISCORD_FILE_LIMIT) {
                await message.reply(`âš ï¸ Audio file too large for Discord (${(fileBuffer.length / 1024 / 1024).toFixed(2)}MB > 25MB limit)`);
                return;
            }
            const filename = path_1.default.basename(media.filePath);
            await message.reply({
                content: text || 'ðŸŽµ Generated audio',
                files: [{
                        attachment: media.filePath,
                        name: filename
                    }]
            });
            logger_1.log.info('[MediaHandler] Audio uploaded to Discord', {
                filename,
                size: `${(fileBuffer.length / 1024).toFixed(2)}KB`
            });
        }
        else {
            throw new Error('No file path or URL provided');
        }
    }
    catch (error) {
        logger_1.log.error('[MediaHandler] Failed to upload media to Discord', {
            error: error.message,
            stack: error.stack,
            type: media.type
        });
        throw error;
    }
}
/**
 * Get file extension for media type
 */
function getExtension(type) {
    switch (type) {
        case 'image': return 'png';
        case 'video': return 'mp4';
        case 'audio': return 'mp3';
        default: return 'bin';
    }
}
